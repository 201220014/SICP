---
description: 程序的元素
---

# 🎡 程序的元素

## 概述

一门编程语言并不只是一种指导计算机完成任务的手段，它同时也是我们**组织自己想法的一个框架**。程序同时也是编程者们相互交流的一种方式，也正因如此，我们编写的程序必须是让人来读的，只不过它刚好也可以被机器运行罢了。人永远比机器重要。

当我们描述一种语言的时候，我们应该重点关注，这种语言提供了怎样的手段让我们能够将简单的想法结合起来从而形成更加复杂的想法。每一种高级的编程语言都有如下三种基本的手段：

* **基础表达式和语句**：它们代表了这门语言提供的最简单的砖块，也是我们日后构建复杂程序最基本的建材；
* **结合的手段**：复杂的元素是由简单的元素通过这些结合的手段形成的；
* **抽象的方法**：通过这些抽象的方法，复杂的元素应当能够被当成一个整体来进行命名与操作。

在程序中，我们会处理两种元素：函数与数据。（不久之后，我们会发现，此二者的区别并不是绝对的，两者相差无几。）简单来说，数据是我们想要操作的东西，函数描述了我们操作数据的规则与过程。

因此，任何的高级程序设计语言都应当能够描述一些基本的数据（比如整数与小数）和函数（比如加减乘除之类的数学运算），同时也应当拥有一些将数据和函数结合起来、抽象起来的方法。

## 表达式（Expressions）

从此处开始，我们将一点一点地基于Python语言搭建程序的大厦，起初会比较简单，请保持耐心，平凡之后的卓越将在不久后到来。

我们先从**基本表达式（Primitive Expression）**开始。一种基本的表达式是一个数字，更加准确地说，是一个仅由阿拉伯数字符号组成的十进制数。

```python
>>> 42
42
```

仅由数字组成的基本表达式可以通过数学符号相联结，形成一个复杂一点的**复合表达式（Compound Expression）**，解释器将会**评估(evaluate)**这个表达式的值：

```python
>>> -1 - -1
0
>>> 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/128
0.9921875
```

这些数学表达式使用了**中缀(infix)表示法**，**操作符**（**operator**，比如说`+, -, *, /`）出现在**操作数**（**operands**，比如说数字）之间。Python中囊括了很多形成复合表达式的方法。我们不会一下子把它们都枚举出来，而是在我们不断深入的过程中逐渐引入新的表达式形式。并且与此同时，也慢慢加入Python语言所支持的特性。

{% hint style="info" %}
表达式是一个能够导出值的东西，只要在Python交互式解释器中能够返回值的都是表达式。
{% endhint %}

## 调用表达式（Call Expression）

调用表达式是最重要的一种复合表达式了，它将一个函数作用于一些参数。从代数的角度来看，函数是从一些输入参数到一个输出值之间的映射。Python表示函数作用的记号和传统的数学记号一样：

```python
>>> max(7.5, 9.5)
9.5
```

调用表达式是含有**子表达式（subexpressions）**的，它由括号外面的操作符与括号里面的操作数列表组成，每一个操作符或者操作数本身也是一个表达式。

> 这里需要理解一下，表达式是一个返回值的东西，无论这个值是一个数据还是一个过程。

```
    max     (     7.5    ,      9.5    )
>----------< >----------<  >----------<
  Operator      Operand        Operand
```

操作符表示了一个函数过程。当这个调用表达式被**评估（evaluate）**的时候，我们称函数`max`被调用了，实际参数（简称实参，**argument**）为7.5和9.5，返回值为9.5。

在调用表达式中，实参的顺序是有考量的。比如说，`pow`函数，一个求指数的函数，`pow(a, b`返回$$a^b$$。

```python
>>> pow(100, 2) # 100^2
10000
>>> pow(2, 100) # 2^100
1267650600228229401496703205376
```

相比于中缀形式的数学表示法，这种**函数调用（function call）**的表示法有3个主要的优点：

第一，函数可以有任意个数的参数，并且不会有歧义，因为函数名永远在参数前面。

```python
>>> max(1, -2, 3, -4)
3
```

第二，函数调用表示法拓展了一种十分直接的方式来**嵌套表达式（nested expressions）**。嵌套表达式是指表达式的操作符或者操作数中存在某一项本身也是一个表达式。

> 因为表达式本身就只是一个返回值的东西罢了，所以我们需要值的时候就可以用一个表达式来替代，从而形成了更复杂的嵌套表达式。

```python
>>> max(min(1, -2), min(pow(3, 5), -4)
-2
```

原则上嵌套表达式的深度以及复杂程度是没有限制的，无论多么复杂，python解释器应当总是能够评估出这个嵌套表达式的值的。然而，人类可能在这样的复杂嵌套面前很容易就变得迷惑了。

不过，对于作为编程者的你来说，你应当尽自己所能，来组织表达式的结构，使得它能够被你自己解释读懂，能够被与你一起合作编程的伙伴们读懂，能够被未来可能会阅读你的表达式的其他人读懂。

第三，数学表达式有着大量繁杂的符号体系，各种运算符、各种上下标、各种上划线、下划线、向量的表示、求和的表示、根号、分式......这些一方面不容易记忆，另一方面也不太容易用我们的键盘打出来。然而，所有的这些复杂的记号都可以通过调用表达式的方式来描述。

Python本身也支持许多常用数学符号的调用表达式形式（比如加法`add`，求根号`sqrt`等等）。任何的操作符都可以被表达成一个带名字的函数。

## 引入库函数

Python定义了非常多的函数，包括上一节提到的各种操作符对应的函数。但是，Python没有默认这些函数都可以直接使用。相反，Python将这些内置的函数，以及其它一些东西按照逻辑上的关联性组织成了许多的模块，这些模块结合起来就组成了Python的**库（library）**。比如说，`math`模块提供了大量常用的数学函数：

```python
>>> from math import sqrt
>>> sqrt(256)
16.0
```

再比如说，`operator`模块提供了许多与中缀操作符相对应函数：

```python
>>> from operator import add, sub, mul
>>> add(14, 28)
42
>>> sub(100, mul(7, add(8, 4)))
16
```

一个`import`语句一般先指定一个模块的名字（比如说`operator`或者`math`），然后列出我们所需要的具体成分（比如说平方根`sqrt`，或者圆周率`pi`）。一旦一个函数或者变量被引入了，它可以被调用或者使用很多次。

使用操作符函数与使用操作符符号，这两者本质上没有任何区别，只不过是写法不一样而已。一般情况下，大多数程序员会使用符号与中缀表示法来书写简单的代数表达式。

Python3库文档里面列出了Python所有的内置模块以及每个模块的所有成分。链接如下：

{% embed url="https://docs.python.org/3/library/index.html" %}
python3 标准库文档
{% endembed %}

不过，这个文档是为已经熟知整个python语言的开发者写的。如果读者是python的初学者，可能相比于读文档，直接上手敲一敲这个函数能够告诉你更多关于这个函数你想知道的东西。在你慢慢熟悉了Python语言之后，这份文档将会变成一个宝贵的参考资料。

## 名字(Name)与环境(Environment)

一门编程语言非常重要的地方在于，它提供了一种方式或者说手段，能够让我们用一个名字简单地指代某个可以计算的对象。如果一个值被给予了一个名字，我们称这个**名字(name)**和这个**值(value)**被**绑定(bind)**在了一起。

在Python中，我们可以通过**赋值语句(Assignment Statement)**的方式来建立新的绑定，包括`=`左边的名字和`=`右边的值：

```python
>>> radius = 10
>>> radius
10
>>> 2 * radius
20
```

{% hint style="info" %}
这里我们可以看到，当我们在交互式解释器中输入radius = 10的时候，python并没有给我们返回任何值，这也就说明了radius = 10不是表达式，因为表达式是一个返回值的东西。

所以我们称python中的赋值为赋值语句，而不是赋值表达式，这与C/C++是不同的。
{% endhint %}

通过`import`语句也可以建立名字与值之间的绑定：

```python
>>> from math import pi
>>> pi * 71 / 223
1.0002380197528042
```

在Python中（其实许多别的语言也是这样的），`=`符号被称为赋值操作符。复制操作是我们最简单的**抽象(abstraction)**方式，因为它使得我们能够用一个简单的名字来指代一系列复杂操作的结果，比如说上面的面积。

通过这样的方式，复杂的程序可以一步一步的被搭建起来，通过不断计算结果，然后用名字指代结果，再计算更复杂的结果的方式。

能够将名字和值绑定在一起，并在之后通过名字来访问值，这就说明了Python解释器必须维护一小块内存，这个内存中存放了名字、值以及名字和值之间的绑定关系。简单来说，就是需要维持一张**名值表（name-value table）**。这一小块内存，也就是这一张名值表，我们称之为**环境（environment）**。

名字也可以被绑定到函数。比如说，名字`max`就被绑定到了最大值函数。不过函数不像数字，可能不是很方便用文本表示，所以当我们询问一个函数的名字的时候（名字本身也是表达式，而表达式是一个返回值的东西）Python解释器会给我们一个像身份证一样的标识信息，比如说：

```python
>>> max
<built-in function max>
```

我们可以用赋值语句给已经存在的函数一个新的名字，就像普通的变量一样：

```cpp
>>> f = max
>>> f
<built-in function max>
>>> f(2, 3, 4)
4
```

并且后续的赋值语句可以将一个名字重新绑定到一个新的值:

```python
>>> f = 2
>>> f
2
```

{% hint style="info" %}
从上面的叙述中，我们可以隐约感知到，函数本身也是一个值，它和普通的数值数据似乎地位上是平等的，此处暂时按下不表，后续会有详细的相关内容。
{% endhint %}

在Python中，名字一般被称为**变量（variable）**或者**变量名（variable name）**，因为它们在程序执行的过程中可以被绑定到许多不同的值。当一个变量被绑定到一个新的值的时候，它之前的绑定就不存在了，无法再通过它去访问任何一个它之前绑定过的值了。哪怕是内置的名字也是可以被绑定到新的值的。

```python
>>> max = 5
>>> max
5
```

再把`max`这个名字绑定到5的时候，它就不再绑定到之前的最大值函数了，所以，后续任何的想要调用`max(2, 3, 4)`的尝试都会导致一个错误。

当执行一个赋值语句的时候，Python在将`=`右边的值绑定到等号左边的名字之前，会先评估等号右边的表达式，从而得到一个值（再说一遍，表达式是一个返回值的东西）。

也就是说，在`=`右边我们仍然可以使用等号左边的名字去指代值，哪怕这个绑定关系即将被改变，但至少在评估右侧表达式的值的时候原绑定关系还是存在的。

```python
>>> x = 2
>>> x = x + 1
>>> x
3
```

我们也可以在一个赋值语句中完成多次赋值，只需要将对应的名字和值放在`=`的左右侧，依次排列用逗号隔开即可。

```python
>>> area, circumference = pi * radius * radius, 2 * pi * radius
>>> area
314.1592653589793
>>> circumference
62.83185307179586
```

改变一个名字的值并不会影响其他的名字。比如在下面的例子中，即使`area`这个名字之前被绑定到了一个由`radius`计算出来的值中，`radius`的改变也不会引起`area`的改变，更新`area`的值需要一个新的赋值语句。

```python
>>> radius = 11
>>> area
314.1592653589793
>>> area = pi * radius * radius
>>> area
380.132711084365
```

在多元赋值语句当中，**所有**的`=`右侧的表达式都会被评估成值，在所有的右侧表达式都被评估成值之后，这些值才会被一起绑定到`=`左边的名字。由于这个规则，交换两个名字绑定的值可以用一个简单的语句完成：

```python
>>> x, y = 3, 4.5
>>> y, x = x, y
>>> x
4.5
>>> y
3
```

{% hint style="info" %}
根据上面的内容，我们可以把赋值语句的执行规则总结如下：

1. 评估赋值符号右侧的表达式；
2. 将得到的值**同时**绑定到左边的名字中。
{% endhint %}

## 评估(Evaluate)嵌套表达式

我们在这一章的一个目标是能够通过程式化思维的方式来剥离问题。举个例子，我们可以思考一下，在评估嵌套表达式的值的时候，解释器自己其实也是遵循了一个固定的步骤的。

为了评估一个调用表达式的值，Python会做下面两件事：

1. 评估操作符和操作数子表达式（因为操作符和操作数本身也是值，而表达式就是返回值的东西，所以我们称可以认为操作符和操作数是子表达式）
2. 将函数作用于实参得到这个表达式的值，其中，这里所说的函数是操作符子表达式被评估之后得到的值，这里所说的实参是指操作数子表达式被评估之后得到的值。

即使是这样简单的步骤，其实也揭示了一些通用过程的重要的要点。从第一步中我们可以看到，为了评估这个表达式的值，我们必须将同样的评估过程应用于它的每一个子表达式，得到每个子表达式的值。于是，我们可以很清晰地看到，这种评估的过程是一种天然的**递归（recursive）**的过程。

所谓递归，其实就是完成评估这个过程本身的步骤当中也需要用到评估的规则，简单理解就是一个俄罗斯套娃的过程，我们之后会详细讨论，这里不作赘述。

比如说，评估下面的这个表达式需要重复上述步骤整整4次。

```python
>>> sub(pow(2, add(1, 10)), pow(2, 5))
2016
```

> 哈哈哈哈，这里可以猜到这个CP的第二版本是2016年编成的。

如果我们画出我们评估的每个表达式，我们可以将这样的层级结构化成如下的图示。

![表达式评估树状结构](../.gitbook/assets/expression\_tree.png)

这种表示方法被称为**表达式树（expression tree）**。在计算机科学中，一般的树状结构都是从上往下生长的，不过这只是一种习惯罢了。树中每个点处的东西我们称之为**结点（node）**，在这个例子中，结点就是各个表达式。

想要评估**根节点（root）**，顶部的完整表达式，我们需要先评估每一个树枝，也就是它的子表达式。**叶子（leaf）**表达式，也就是没有子表达式的结点，一般情况下是函数或者数字。中间的结点有两个部分组成：需要应用我们上面所提到的规则的子表达式、该表达式的结果值。从这棵树的角度来看，我们可以想象到，操作数的值是从下向上渗透的，从叶子结点开始，满满的评估，组合，再评估，再组合，从而解决越来越复杂、越来越高阶的问题。

我们可以观察到，不断地重复第一个步骤可以将我们从调用表达式带到非调用表达式，也就是**基础表达式（primitive expressions）**，比如说数字、名字之类的。处理这种基础表达式的规则是：

* 评估一个数字得到的值就是这个数字所表示的数值
* 评估一个名字得到的值就是在当前环境中这个名字所绑定到的值

注意到环境在决定表达式中符号的含义的时候是很重要的，如果没有给一个名字绑定值的话，使用这个名字访问值是会报错的。比如说：

```python
>>> add(x, 1)
```

如果在当前环境中，这里的x没有被绑定到一个值，那么Python解释器是会报错的。甚至说，如果当前的环境中，这里的`add`没有被绑定到一个值，Python解释器也是会报错的。

环境提供了评估的语境，评估总是在一个特定的环境所对应的语境中发生的。因此，在我们理解程序的执行的时候，明确当前语句或者表达式所对应的环境是很重要的。

我们上面的提到的评估表达式相关的内容其实并不是对于所有的Python代码都适用的，而是针对调用表达式、数字以及名字。比如说，评估相关的内容并不适用于赋值语句：

```python
>>> x = 3
```

执行这个语句并不会返回值，同时也不会发生函数调用，也就不需要评估。因为赋值的目的其实是建立一个名字和一个值之间的对应关系，所以也不需要返回值。

> 不过在赋值语句的右侧可能是一个表达式，这个时候对于局部来讲，是会有评估的过程发生的。

总的来说，**语句并不是用来评估的，而是用来执行（execute）的；语句并不会返回值，但是它们会造成一些影响。**比如说赋值语句会对当前环境造成影响，产生一个新的绑定或者修改一个旧的绑定。每一种类型的表达式或者语句都有它自己的一套评估或者执行的流程。

{% hint style="info" %}
当我们说数字评估得到数值的时候，我们其实是在说Python解释器会把数字评估成数值。因为解释器本身也是一个人写好的程序，所以它的行为是始终如一的，因此我们才会这么说。但其实评估的规则是由语言自己决定的。

比如说汇编语言里面，不同未知的数值可能被评估成数值，也可能被评估成地址，还可能被评估成偏移量、基址、比例系数等等。

所以，读这本书一定要有一个高于具体某一门语言的更加抽象的认知。
{% endhint %}

## 不纯洁（non-pure）的打印函数

从这里开始，我们区分两种函数。

**纯洁的函数**：函数有一些输入（它们的实参）并且返回一些输出（调用他们所得到的结果）。但是除此之外没有任何别的行为发生。

比如说，内置函数`abs`可以视为一个小小的机器，纳入原料然后吐出结果：

```python
>>> abs(-2)
2
```

![函数abs](../.gitbook/assets/function\_abs.png)

`abs`这个函数就是纯洁的。纯洁的函数有一个特征，就是当调用它们的时候，他们不会产生任何的除了返回值之外的其他影响。除此之外，纯洁的函数，当我们用同样的实参调用两次的时候，它应当返回同样的值。

{% hint style="info" %}
简单来说，纯洁的函数应当是一个独立的模块，它不应当对外界产生任何影响，同时也不应当受到外界的任何影响。
{% endhint %}

**不纯洁的函数**：除了返回值之外，调用一个不纯洁的函数

















